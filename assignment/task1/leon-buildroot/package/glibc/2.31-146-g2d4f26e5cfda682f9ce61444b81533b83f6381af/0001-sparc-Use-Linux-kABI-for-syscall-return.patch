From 987d5861c2ccaa327a1566ab93aade36663130ce Mon Sep 17 00:00:00 2001
From: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date: Tue, 28 Jan 2020 19:33:01 -0300
Subject: [PATCH 01/14] sparc: Use Linux kABI for syscall return

It changes the sparc internal_syscall* macros to return a negative
value instead of the 'g1' register value in the 'err' macro argument.
The __SYSCALL_STRING macro is also changed to no set the 'g1'
value, since 'o1' already holds all the required information
to check if syscall has failed.

The macro INTERNAL_SYSCALL_DECL is no longer required, and the
INTERNAL_SYSCALL_ERROR_P macro follows the other Linux kABIs.
The redefinition of INTERNAL_VSYSCALL_CALL is also no longer
required.

Checked on sparc64-linux-gnu and sparcv9-linux-gnu. It fixes
the sporadic issues on sparc32 where clock_nanosleep does not
act as cancellation entrypoint.

(cherry-picked from commit 86c5d2cf0ce046279baddc7faa27da71f1a89fde)
---
 .../unix/sysv/linux/sparc/sparc32/sysdep.h    |  3 +-
 .../unix/sysv/linux/sparc/sparc64/sysdep.h    |  3 +-
 sysdeps/unix/sysv/linux/sparc/sysdep.h        | 80 +++++++++----------
 3 files changed, 38 insertions(+), 48 deletions(-)

diff --git a/sysdeps/unix/sysv/linux/sparc/sparc32/sysdep.h b/sysdeps/unix/sysv/linux/sparc/sparc32/sysdep.h
index 8461261674..2c3754770b 100644
--- a/sysdeps/unix/sysv/linux/sparc/sparc32/sysdep.h
+++ b/sysdeps/unix/sysv/linux/sparc/sparc32/sysdep.h
@@ -110,9 +110,8 @@ ENTRY(name);					\
 #define __SYSCALL_STRING						\
 	"ta	0x10;"							\
 	"bcc	1f;"							\
-	" mov	0, %%g1;"						\
+	" nop;"								\
 	"sub	%%g0, %%o0, %%o0;"					\
-	"mov	1, %%g1;"						\
 	"1:"
 
 #define __SYSCALL_CLOBBERS						\
diff --git a/sysdeps/unix/sysv/linux/sparc/sparc64/sysdep.h b/sysdeps/unix/sysv/linux/sparc/sparc64/sysdep.h
index b9a4c75cbd..2010faf50f 100644
--- a/sysdeps/unix/sysv/linux/sparc/sparc64/sysdep.h
+++ b/sysdeps/unix/sysv/linux/sparc/sparc64/sysdep.h
@@ -109,9 +109,8 @@ ENTRY(name);					\
 #define __SYSCALL_STRING						\
 	"ta	0x6d;"							\
 	"bcc,pt	%%xcc, 1f;"						\
-	" mov	0, %%g1;"						\
+	" nop;"								\
 	"sub	%%g0, %%o0, %%o0;"					\
-	"mov	1, %%g1;"						\
 	"1:"
 
 #define __SYSCALL_CLOBBERS						\
diff --git a/sysdeps/unix/sysv/linux/sparc/sysdep.h b/sysdeps/unix/sysv/linux/sparc/sysdep.h
index 0c32780d9c..10dad895cd 100644
--- a/sysdeps/unix/sysv/linux/sparc/sysdep.h
+++ b/sysdeps/unix/sysv/linux/sparc/sysdep.h
@@ -34,13 +34,6 @@
 
 #else	/* __ASSEMBLER__ */
 
-#define INTERNAL_VSYSCALL_CALL(funcptr, err, nr, args...)		\
-  ({									\
-    long _ret = funcptr (args);						\
-    err = ((unsigned long) (_ret) >= (unsigned long) -4095L);		\
-    _ret;								\
-  })
-
 # define VDSO_NAME  "LINUX_2.6"
 # define VDSO_HASH  61765110
 
@@ -65,108 +58,107 @@
 })
 
 #undef INTERNAL_SYSCALL_DECL
-#define INTERNAL_SYSCALL_DECL(err) \
-	register long err __asm__("g1");
+#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
 
 #undef INTERNAL_SYSCALL
 #define INTERNAL_SYSCALL(name, err, nr, args...) \
-  inline_syscall##nr(__SYSCALL_STRING, err, __NR_##name, args)
+  internal_syscall##nr(__SYSCALL_STRING, err, __NR_##name, args)
 
 #undef INTERNAL_SYSCALL_NCS
 #define INTERNAL_SYSCALL_NCS(name, err, nr, args...) \
-  inline_syscall##nr(__SYSCALL_STRING, err, name, args)
+  internal_syscall##nr(__SYSCALL_STRING, err, name, args)
 
 #undef INTERNAL_SYSCALL_ERROR_P
 #define INTERNAL_SYSCALL_ERROR_P(val, err) \
-  ((void) (val), __builtin_expect((err) != 0, 0))
+  ((unsigned long int) (val) > -4096UL)
 
 #undef INTERNAL_SYSCALL_ERRNO
 #define INTERNAL_SYSCALL_ERRNO(val, err)	(-(val))
 
-#define inline_syscall0(string,err,name,dummy...)			\
+#define internal_syscall0(string,err,name,dummy...)			\
 ({									\
+	register long int __g1 __asm__ ("g1") = (name);			\
 	register long __o0 __asm__ ("o0");				\
-	err = name;							\
-	__asm __volatile (string : "=r" (err), "=r" (__o0) :		\
-			  "0" (err) :					\
+	__asm __volatile (string : "=r" (__o0) :			\
+			  "r" (__g1) :					\
 			  __SYSCALL_CLOBBERS);				\
 	__o0;								\
 })
 
-#define inline_syscall1(string,err,name,arg1)				\
+#define internal_syscall1(string,err,name,arg1)				\
 ({									\
+	register long int __g1 __asm__("g1") = (name);			\
 	register long __o0 __asm__ ("o0") = (long)(arg1);		\
-	err = name;							\
-	__asm __volatile (string : "=r" (err), "=r" (__o0) :		\
-			  "0" (err), "1" (__o0) :			\
+	__asm __volatile (string : "=r" (__o0) :			\
+			  "r" (__g1), "0" (__o0) :			\
 			  __SYSCALL_CLOBBERS);				\
 	__o0;								\
 })
 
-#define inline_syscall2(string,err,name,arg1,arg2)			\
+#define internal_syscall2(string,err,name,arg1,arg2)			\
 ({									\
+	register long int __g1 __asm__("g1") = (name);			\
 	register long __o0 __asm__ ("o0") = (long)(arg1);		\
 	register long __o1 __asm__ ("o1") = (long)(arg2);		\
-	err = name;							\
-	__asm __volatile (string : "=r" (err), "=r" (__o0) :		\
-			  "0" (err), "1" (__o0), "r" (__o1) :		\
+	__asm __volatile (string : "=r" (__o0) :			\
+			  "r" (__g1), "0" (__o0), "r" (__o1) :		\
 			  __SYSCALL_CLOBBERS);				\
 	__o0;								\
 })
 
-#define inline_syscall3(string,err,name,arg1,arg2,arg3)			\
+#define internal_syscall3(string,err,name,arg1,arg2,arg3)		\
 ({									\
+	register long int __g1 __asm__("g1") = (name);			\
 	register long __o0 __asm__ ("o0") = (long)(arg1);		\
 	register long __o1 __asm__ ("o1") = (long)(arg2);		\
 	register long __o2 __asm__ ("o2") = (long)(arg3);		\
-	err = name;							\
-	__asm __volatile (string : "=r" (err), "=r" (__o0) :		\
-			  "0" (err), "1" (__o0), "r" (__o1),		\
+	__asm __volatile (string : "=r" (__o0) :			\
+			  "r" (__g1), "0" (__o0), "r" (__o1),		\
 			  "r" (__o2) :					\
 			  __SYSCALL_CLOBBERS);				\
 	__o0;								\
 })
 
-#define inline_syscall4(string,err,name,arg1,arg2,arg3,arg4)		\
+#define internal_syscall4(string,err,name,arg1,arg2,arg3,arg4)		\
 ({									\
+	register long int __g1 __asm__("g1") = (name);			\
 	register long __o0 __asm__ ("o0") = (long)(arg1);		\
 	register long __o1 __asm__ ("o1") = (long)(arg2);		\
 	register long __o2 __asm__ ("o2") = (long)(arg3);		\
 	register long __o3 __asm__ ("o3") = (long)(arg4);		\
-	err = name;							\
-	__asm __volatile (string : "=r" (err), "=r" (__o0) :		\
-			  "0" (err), "1" (__o0), "r" (__o1),		\
+	__asm __volatile (string : "=r" (__o0) :			\
+			  "r" (__g1), "0" (__o0), "r" (__o1),		\
 			  "r" (__o2), "r" (__o3) :			\
 			  __SYSCALL_CLOBBERS);				\
 	__o0;								\
 })
 
-#define inline_syscall5(string,err,name,arg1,arg2,arg3,arg4,arg5)	\
+#define internal_syscall5(string,err,name,arg1,arg2,arg3,arg4,arg5)	\
 ({									\
+	register long int __g1 __asm__("g1") = (name);			\
 	register long __o0 __asm__ ("o0") = (long)(arg1);		\
 	register long __o1 __asm__ ("o1") = (long)(arg2);		\
 	register long __o2 __asm__ ("o2") = (long)(arg3);		\
 	register long __o3 __asm__ ("o3") = (long)(arg4);		\
 	register long __o4 __asm__ ("o4") = (long)(arg5);		\
-	err = name;							\
-	__asm __volatile (string : "=r" (err), "=r" (__o0) :		\
-			  "0" (err), "1" (__o0), "r" (__o1),		\
+	__asm __volatile (string : "=r" (__o0) :			\
+			  "r" (__g1), "0" (__o0), "r" (__o1),		\
 			  "r" (__o2), "r" (__o3), "r" (__o4) :		\
 			  __SYSCALL_CLOBBERS);				\
 	__o0;								\
 })
 
-#define inline_syscall6(string,err,name,arg1,arg2,arg3,arg4,arg5,arg6)	\
+#define internal_syscall6(string,err,name,arg1,arg2,arg3,arg4,arg5,arg6)\
 ({									\
+	register long int __g1 __asm__("g1") = (name);			\
 	register long __o0 __asm__ ("o0") = (long)(arg1);		\
 	register long __o1 __asm__ ("o1") = (long)(arg2);		\
 	register long __o2 __asm__ ("o2") = (long)(arg3);		\
 	register long __o3 __asm__ ("o3") = (long)(arg4);		\
 	register long __o4 __asm__ ("o4") = (long)(arg5);		\
 	register long __o5 __asm__ ("o5") = (long)(arg6);		\
-	err = name;							\
-	__asm __volatile (string : "=r" (err), "=r" (__o0) :		\
-			  "0" (err), "1" (__o0), "r" (__o1),		\
+	__asm __volatile (string : "=r" (__o0) :			\
+			  "r" (__g1), "0" (__o0), "r" (__o1),		\
 			  "r" (__o2), "r" (__o3), "r" (__o4),		\
 			  "r" (__o5) :					\
 			  __SYSCALL_CLOBBERS);				\
@@ -182,13 +174,13 @@
 	register long __o4 __asm__ ("o4") = (long)(arg5);		\
 	register long __g1 __asm__ ("g1") = __NR_clone;			\
 	__asm __volatile (__SYSCALL_STRING :				\
-			  "=r" (__g1), "=r" (__o0), "=r" (__o1)	:	\
-			  "0" (__g1), "1" (__o0), "2" (__o1),		\
+			  "=r" (__o0), "=r" (__o1) :			\
+			  "r" (__g1), "0" (__o0), "1" (__o1),		\
 			  "r" (__o2), "r" (__o3), "r" (__o4) :		\
 			  __SYSCALL_CLOBBERS);				\
-	if (INTERNAL_SYSCALL_ERROR_P (__o0, __g1))			\
+	if (__glibc_unlikely ((unsigned long int) (__o0) > -4096UL))	\
 	  {		     			       		   	\
-	    __set_errno (INTERNAL_SYSCALL_ERRNO (__o0, __g1));		\
+	    __set_errno (-__o0);					\
 	    __o0 = -1L;			    				\
 	  } 	      							\
 	else								\
-- 
2.34.1

