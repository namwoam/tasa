<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 6. Buildroot configuration</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="home" href="index.html" title="The Buildroot user manual" /><link rel="up" href="pt02.html" title="Part II. User guide" /><link rel="prev" href="pt02.html" title="Part II. User guide" /><link rel="next" href="ch07.html" title="Chapter 7. Configuration of other components" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="pt02.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch07.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="configure"></a>Chapter 6. Buildroot configuration</h2></div></div></div><p>All the configuration options in <code class="literal">make *config</code> have a help text
providing details about the option.</p><p>The <code class="literal">make *config</code> commands also offer a search tool. Read the help
message in the different frontend menus to know how to use it:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
in <span class="emphasis"><em>menuconfig</em></span>, the search tool is called by pressing <code class="literal">/</code>;
</li><li class="listitem">
in <span class="emphasis"><em>xconfig</em></span>, the search tool is called by pressing <code class="literal">Ctrl</code> + <code class="literal">f</code>.
</li></ul></div><p>The result of the search shows the help message of the matching items.
In <span class="emphasis"><em>menuconfig</em></span>, numbers in the left column provide a shortcut to the
corresponding entry. Just type this number to directly jump to the
entry, or to the containing menu in case the entry is not selectable due
to a missing dependency.</p><p>Although the menu structure and the help text of the entries should be
sufficiently self-explanatory, a number of topics require additional
explanation that cannot easily be covered in the help text and are
therefore covered in the following sections.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_cross_compilation_toolchain"></a>6.1. Cross-compilation toolchain</h2></div></div></div><p>A compilation toolchain is the set of tools that allows you to compile
code for your system. It consists of a compiler (in our case, <code class="literal">gcc</code>),
binary utils like assembler and linker (in our case, <code class="literal">binutils</code>) and a
C standard library (for example
<a class="ulink" href="http://www.gnu.org/software/libc/libc.html" target="_top">GNU Libc</a>,
<a class="ulink" href="http://www.uclibc-ng.org/" target="_top">uClibc-ng</a>).</p><p>The system installed on your development station certainly already has
a compilation toolchain that you can use to compile an application
that runs on your system. If you’re using a PC, your compilation
toolchain runs on an x86 processor and generates code for an x86
processor. Under most Linux systems, the compilation toolchain uses
the GNU libc (glibc) as the C standard library. This compilation
toolchain is called the "host compilation toolchain". The machine on
which it is running, and on which you’re working, is called the "host
system" <a href="#ftn.idm370" class="footnote" id="idm370"><sup class="footnote">[3]</sup></a>.</p><p>The compilation toolchain is provided by your distribution, and
Buildroot has nothing to do with it (other than using it to build a
cross-compilation toolchain and other tools that are run on the
development host).</p><p>As said above, the compilation toolchain that comes with your system
runs on and generates code for the processor in your host system. As
your embedded system has a different processor, you need a
cross-compilation toolchain - a compilation toolchain that runs on
your <span class="emphasis"><em>host system</em></span> but generates code for your <span class="emphasis"><em>target system</em></span> (and
target processor). For example, if your host system uses x86 and your
target system uses ARM, the regular compilation toolchain on your host
runs on x86 and generates code for x86, while the cross-compilation
toolchain runs on x86 and generates code for ARM.</p><p>Buildroot provides two solutions for the cross-compilation toolchain:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The <span class="strong"><strong>internal toolchain backend</strong></span>, called <code class="literal">Buildroot toolchain</code> in
   the configuration interface.
</li><li class="listitem">
The <span class="strong"><strong>external toolchain backend</strong></span>, called <code class="literal">External toolchain</code> in
   the configuration interface.
</li></ul></div><p>The choice between these two solutions is done using the <code class="literal">Toolchain
Type</code> option in the <code class="literal">Toolchain</code> menu. Once one solution has been
chosen, a number of configuration options appear, they are detailed in
the following sections.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="internal-toolchain-backend"></a>6.1.1. Internal toolchain backend</h3></div></div></div><p>The <span class="emphasis"><em>internal toolchain backend</em></span> is the backend where Buildroot builds
by itself a cross-compilation toolchain, before building the userspace
applications and libraries for your target embedded system.</p><p>This backend supports several C libraries:
<a class="ulink" href="http://www.uclibc-ng.org" target="_top">uClibc-ng</a>,
<a class="ulink" href="http://www.gnu.org/software/libc/libc.html" target="_top">glibc</a> and
<a class="ulink" href="http://www.musl-libc.org" target="_top">musl</a>.</p><p>Once you have selected this backend, a number of options appear. The
most important ones allow to:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Change the version of the Linux kernel headers used to build the
   toolchain. This item deserves a few explanations. In the process of
   building a cross-compilation toolchain, the C library is being
   built. This library provides the interface between userspace
   applications and the Linux kernel. In order to know how to "talk"
   to the Linux kernel, the C library needs to have access to the
   <span class="emphasis"><em>Linux kernel headers</em></span> (i.e. the <code class="literal">.h</code> files from the kernel), which
   define the interface between userspace and the kernel (system
   calls, data structures, etc.). Since this interface is backward
   compatible, the version of the Linux kernel headers used to build
   your toolchain do not need to match <span class="emphasis"><em>exactly</em></span> the version of the
   Linux kernel you intend to run on your embedded system. They only
   need to have a version equal or older to the version of the Linux
   kernel you intend to run. If you use kernel headers that are more
   recent than the Linux kernel you run on your embedded system, then
   the C library might be using interfaces that are not provided by
   your Linux kernel.
</li><li class="listitem">
Change the version of the GCC compiler, binutils and the C library.
</li><li class="listitem">
Select a number of toolchain options (uClibc only): whether the
   toolchain should have RPC support (used mainly for NFS),
   wide-char support, locale support (for internationalization),
   C++ support or thread support. Depending on which options you choose,
   the number of userspace applications and libraries visible in
   Buildroot menus will change: many applications and libraries require
   certain toolchain options to be enabled. Most packages show a comment
   when a certain toolchain option is required to be able to enable
   those packages. If needed, you can further refine the uClibc
   configuration by running <code class="literal">make uclibc-menuconfig</code>. Note however that
   all packages in Buildroot are tested against the default uClibc
   configuration bundled in Buildroot: if you deviate from this
   configuration by removing features from uClibc, some packages may no
   longer build.
</li></ul></div><p>It is worth noting that whenever one of those options is modified,
then the entire toolchain and system must be rebuilt. See
<a class="xref" href="ch08.html#full-rebuild" title="8.2. Understanding when a full rebuild is necessary">Section 8.2, “Understanding when a full rebuild is necessary”</a>.</p><p>Advantages of this backend:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Well integrated with Buildroot
</li><li class="listitem">
Fast, only builds what’s necessary
</li></ul></div><p>Drawbacks of this backend:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Rebuilding the toolchain is needed when doing <code class="literal">make clean</code>, which
  takes time. If you’re trying to reduce your build time, consider
  using the <span class="emphasis"><em>External toolchain backend</em></span>.
</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="external-toolchain-backend"></a>6.1.2. External toolchain backend</h3></div></div></div><p>The <span class="emphasis"><em>external toolchain backend</em></span> allows to use existing pre-built
cross-compilation toolchains. Buildroot knows about a number of
well-known cross-compilation toolchains (from
<a class="ulink" href="http://www.linaro.org" target="_top">Linaro</a> for ARM,
<a class="ulink" href="http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/editions/lite-edition/" target="_top">Sourcery
CodeBench</a> for ARM, x86-64, PowerPC, and MIPS, and is capable of
downloading them automatically, or it can be pointed to a custom
toolchain, either available for download or installed locally.</p><p>Then, you have three solutions to use an external toolchain:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Use a predefined external toolchain profile, and let Buildroot
  download, extract and install the toolchain. Buildroot already knows
  about a few CodeSourcery and Linaro toolchains. Just select the
  toolchain profile in <code class="literal">Toolchain</code> from the available ones. This is
  definitely the easiest solution.
</li><li class="listitem">
Use a predefined external toolchain profile, but instead of having
  Buildroot download and extract the toolchain, you can tell Buildroot
  where your toolchain is already installed on your system. Just
  select the toolchain profile in <code class="literal">Toolchain</code> through the available
  ones, unselect <code class="literal">Download toolchain automatically</code>, and fill the
  <code class="literal">Toolchain path</code> text entry with the path to your cross-compiling
  toolchain.
</li><li class="listitem">
Use a completely custom external toolchain. This is particularly
  useful for toolchains generated using crosstool-NG or with Buildroot
  itself. To do this, select the <code class="literal">Custom toolchain</code> solution in the
  <code class="literal">Toolchain</code> list. You need to fill the <code class="literal">Toolchain path</code>, <code class="literal">Toolchain
  prefix</code> and <code class="literal">External toolchain C library</code> options. Then, you have
  to tell Buildroot what your external toolchain supports. If your
  external toolchain uses the <span class="emphasis"><em>glibc</em></span> library, you only have to tell
  whether your toolchain supports C++ or not and whether it has
  built-in RPC support. If your external toolchain uses the <span class="emphasis"><em>uClibc</em></span>
  library, then you have to tell Buildroot if it supports RPC,
  wide-char, locale, program invocation, threads and C++.
  At the beginning of the execution, Buildroot will tell you if
  the selected options do not match the toolchain configuration.
</li></ul></div><p>Our external toolchain support has been tested with toolchains from
CodeSourcery and Linaro, toolchains generated by
<a class="ulink" href="http://crosstool-ng.org" target="_top">crosstool-NG</a>, and toolchains generated by
Buildroot itself. In general, all toolchains that support the
<span class="emphasis"><em>sysroot</em></span> feature should work. If not, do not hesitate to contact the
developers.</p><p>We do not support toolchains or SDK generated by OpenEmbedded or
Yocto, because these toolchains are not pure toolchains (i.e. just the
compiler, binutils, the C and C++ libraries). Instead these toolchains
come with a very large set of pre-compiled libraries and
programs. Therefore, Buildroot cannot import the <span class="emphasis"><em>sysroot</em></span> of the
toolchain, as it would contain hundreds of megabytes of pre-compiled
libraries that are normally built by Buildroot.</p><p>We also do not support using the distribution toolchain (i.e. the
gcc/binutils/C library installed by your distribution) as the
toolchain to build software for the target. This is because your
distribution toolchain is not a "pure" toolchain (i.e. only with the
C/C++ library), so we cannot import it properly into the Buildroot
build environment. So even if you are building a system for a x86 or
x86_64 target, you have to generate a cross-compilation toolchain with
Buildroot or crosstool-NG.</p><p>If you want to generate a custom toolchain for your project, that can
be used as an external toolchain in Buildroot, our recommendation is
to build it either with Buildroot itself (see
<a class="xref" href="ch06.html#build-toolchain-with-buildroot" title="6.1.3. Build an external toolchain with Buildroot">Section 6.1.3, “Build an external toolchain with Buildroot”</a>) or with
<a class="ulink" href="http://crosstool-ng.org" target="_top">crosstool-NG</a>.</p><p>Advantages of this backend:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Allows to use well-known and well-tested cross-compilation
  toolchains.
</li><li class="listitem">
Avoids the build time of the cross-compilation toolchain, which is
  often very significant in the overall build time of an embedded
  Linux system.
</li></ul></div><p>Drawbacks of this backend:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
If your pre-built external toolchain has a bug, may be hard to get a
  fix from the toolchain vendor, unless you build your external
  toolchain by yourself using Buildroot or Crosstool-NG.
</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="build-toolchain-with-buildroot"></a>6.1.3. Build an external toolchain with Buildroot</h3></div></div></div><p>The Buildroot internal toolchain option can be used to create an
external toolchain. Here are a series of steps to build an internal
toolchain and package it up for reuse by Buildroot itself (or other
projects).</p><p>Create a new Buildroot configuration, with the following details:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Select the appropriate <span class="strong"><strong>Target options</strong></span> for your target CPU
  architecture
</li><li class="listitem">
In the <span class="strong"><strong>Toolchain</strong></span> menu, keep the default of <span class="strong"><strong>Buildroot toolchain</strong></span>
  for <span class="strong"><strong>Toolchain type</strong></span>, and configure your toolchain as desired
</li><li class="listitem">
In the <span class="strong"><strong>System configuration</strong></span> menu, select <span class="strong"><strong>None</strong></span> as the <span class="strong"><strong>Init
  system</strong></span> and <span class="strong"><strong>none</strong></span> as <span class="strong"><strong>/bin/sh</strong></span>
</li><li class="listitem">
In the <span class="strong"><strong>Target packages</strong></span> menu, disable <span class="strong"><strong>BusyBox</strong></span>
</li><li class="listitem">
In the <span class="strong"><strong>Filesystem images</strong></span> menu, disable <span class="strong"><strong>tar the root filesystem</strong></span>
</li></ul></div><p>Then, we can trigger the build, and also ask Buildroot to generate a
SDK. This will conveniently generate for us a tarball which contains
our toolchain:</p><pre class="screen">make sdk</pre><p>This produces the SDK tarball in <code class="literal">$(O)/images</code>, with a name similar to
<code class="literal">arm-buildroot-linux-uclibcgnueabi_sdk-buildroot.tar.gz</code>. Save this
tarball, as it is now the toolchain that you can re-use as an external
toolchain in other Buildroot projects.</p><p>In those other Buildroot projects, in the <span class="strong"><strong>Toolchain</strong></span> menu:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Set <span class="strong"><strong>Toolchain type</strong></span> to <span class="strong"><strong>External toolchain</strong></span>
</li><li class="listitem">
Set <span class="strong"><strong>Toolchain</strong></span> to <span class="strong"><strong>Custom toolchain</strong></span>
</li><li class="listitem">
Set <span class="strong"><strong>Toolchain origin</strong></span> to <span class="strong"><strong>Toolchain to be downloaded and installed</strong></span>
</li><li class="listitem">
Set <span class="strong"><strong>Toolchain URL</strong></span> to <code class="literal">file:///path/to/your/sdk/tarball.tar.gz</code>
</li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_external_toolchain_wrapper"></a>External toolchain wrapper</h4></div></div></div><p>When using an external toolchain, Buildroot generates a wrapper program,
that transparently passes the appropriate options (according to the
configuration) to the external toolchain programs. In case you need to
debug this wrapper to check exactly what arguments are passed, you can
set the environment variable <code class="literal">BR2_DEBUG_WRAPPER</code> to either one of:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">0</code>, empty or not set: no debug
</li><li class="listitem">
<code class="literal">1</code>: trace all arguments on a single line
</li><li class="listitem">
<code class="literal">2</code>: trace one argument per line
</li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_dev_management"></a>6.2. /dev management</h2></div></div></div><p>On a Linux system, the <code class="literal">/dev</code> directory contains special files, called
<span class="emphasis"><em>device files</em></span>, that allow userspace applications to access the
hardware devices managed by the Linux kernel. Without these <span class="emphasis"><em>device
files</em></span>, your userspace applications would not be able to use the
hardware devices, even if they are properly recognized by the Linux
kernel.</p><p>Under <code class="literal">System configuration</code>, <code class="literal">/dev management</code>, Buildroot offers four
different solutions to handle the <code class="literal">/dev</code> directory :</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The first solution is <span class="strong"><strong>Static using device table</strong></span>. This is the old
   classical way of handling device files in Linux. With this method,
   the device files are persistently stored in the root filesystem
   (i.e. they persist across reboots), and there is nothing that will
   automatically create and remove those device files when hardware
   devices are added or removed from the system. Buildroot therefore
   creates a standard set of device files using a <span class="emphasis"><em>device table</em></span>, the
   default one being stored in <code class="literal">system/device_table_dev.txt</code> in the
   Buildroot source code. This file is processed when Buildroot
   generates the final root filesystem image, and the <span class="emphasis"><em>device files</em></span>
   are therefore not visible in the <code class="literal">output/target</code> directory. The
   <code class="literal">BR2_ROOTFS_STATIC_DEVICE_TABLE</code> option allows to change the
   default device table used by Buildroot, or to add an additional
   device table, so that additional <span class="emphasis"><em>device files</em></span> are created by
   Buildroot during the build. So, if you use this method, and a
   <span class="emphasis"><em>device file</em></span> is missing in your system, you can for example create
   a <code class="literal">board/&lt;yourcompany&gt;/&lt;yourproject&gt;/device_table_dev.txt</code> file
   that contains the description of your additional <span class="emphasis"><em>device files</em></span>,
   and then you can set <code class="literal">BR2_ROOTFS_STATIC_DEVICE_TABLE</code> to
   <code class="literal">system/device_table_dev.txt
   board/&lt;yourcompany&gt;/&lt;yourproject&gt;/device_table_dev.txt</code>. For more
   details about the format of the device table file, see
   <a class="xref" href="ch25.html" title="Chapter 25. Makedev syntax documentation">Chapter 25, <em>Makedev syntax documentation</em></a>.
</li><li class="listitem">
The second solution is <span class="strong"><strong>Dynamic using devtmpfs only</strong></span>. <span class="emphasis"><em>devtmpfs</em></span> is
   a virtual filesystem inside the Linux kernel that has been
   introduced in kernel 2.6.32 (if you use an older kernel, it is not
   possible to use this option). When mounted in <code class="literal">/dev</code>, this virtual
   filesystem will automatically make <span class="emphasis"><em>device files</em></span> appear and
   disappear as hardware devices are added and removed from the
   system. This filesystem is not persistent across reboots: it is
   filled dynamically by the kernel. Using <span class="emphasis"><em>devtmpfs</em></span> requires the
   following kernel configuration options to be enabled:
   <code class="literal">CONFIG_DEVTMPFS</code> and <code class="literal">CONFIG_DEVTMPFS_MOUNT</code>. When Buildroot is in
   charge of building the Linux kernel for your embedded device, it
   makes sure that those two options are enabled. However, if you
   build your Linux kernel outside of Buildroot, then it is your
   responsibility to enable those two options (if you fail to do so,
   your Buildroot system will not boot).
</li><li class="listitem">
The third solution is <span class="strong"><strong>Dynamic using devtmpfs + mdev</strong></span>. This method
   also relies on the <span class="emphasis"><em>devtmpfs</em></span> virtual filesystem detailed above (so
   the requirement to have <code class="literal">CONFIG_DEVTMPFS</code> and
   <code class="literal">CONFIG_DEVTMPFS_MOUNT</code> enabled in the kernel configuration still
   apply), but adds the <code class="literal">mdev</code> userspace utility on top of it. <code class="literal">mdev</code>
   is a program part of BusyBox that the kernel will call every time a
   device is added or removed. Thanks to the <code class="literal">/etc/mdev.conf</code>
   configuration file, <code class="literal">mdev</code> can be configured to for example, set
   specific permissions or ownership on a device file, call a script
   or application whenever a device appears or disappear,
   etc. Basically, it allows <span class="emphasis"><em>userspace</em></span> to react on device addition
   and removal events. <code class="literal">mdev</code> can for example be used to automatically
   load kernel modules when devices appear on the system. <code class="literal">mdev</code> is
   also important if you have devices that require a firmware, as it
   will be responsible for pushing the firmware contents to the
   kernel. <code class="literal">mdev</code> is a lightweight implementation (with fewer
   features) of <code class="literal">udev</code>. For more details about <code class="literal">mdev</code> and the syntax
   of its configuration file, see
   <a class="ulink" href="http://git.busybox.net/busybox/tree/docs/mdev.txt" target="_top">http://git.busybox.net/busybox/tree/docs/mdev.txt</a>.
</li><li class="listitem">
The fourth solution is <span class="strong"><strong>Dynamic using devtmpfs + eudev</strong></span>. This
   method also relies on the <span class="emphasis"><em>devtmpfs</em></span> virtual filesystem detailed
   above, but adds the <code class="literal">eudev</code> userspace daemon on top of it. <code class="literal">eudev</code>
   is a daemon that runs in the background, and gets called by the
   kernel when a device gets added or removed from the system. It is a
   more heavyweight solution than <code class="literal">mdev</code>, but provides higher
   flexibility.  <code class="literal">eudev</code> is a standalone version of <code class="literal">udev</code>, the
   original userspace daemon used in most desktop Linux distributions,
   which is now part of Systemd. For more details, see
   <a class="ulink" href="http://en.wikipedia.org/wiki/Udev" target="_top">http://en.wikipedia.org/wiki/Udev</a>.
</li></ul></div><p>The Buildroot developers recommendation is to start with the <span class="strong"><strong>Dynamic
using devtmpfs only</strong></span> solution, until you have the need for userspace
to be notified when devices are added/removed, or if firmwares are
needed, in which case <span class="strong"><strong>Dynamic using devtmpfs + mdev</strong></span> is usually a
good solution.</p><p>Note that if <code class="literal">systemd</code> is chosen as init system, /dev management will
be performed by the <code class="literal">udev</code> program provided by <code class="literal">systemd</code>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="init-system"></a>6.3. init system</h2></div></div></div><p>The <span class="emphasis"><em>init</em></span> program is the first userspace program started by the
kernel (it carries the PID number 1), and is responsible for starting
the userspace services and programs (for example: web server,
graphical applications, other network servers, etc.).</p><p>Buildroot allows to use three different types of init systems, which
can be chosen from <code class="literal">System configuration</code>, <code class="literal">Init system</code>:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The first solution is <span class="strong"><strong>BusyBox</strong></span>. Amongst many programs, BusyBox has
   an implementation of a basic <code class="literal">init</code> program, which is sufficient
   for most embedded systems. Enabling the <code class="literal">BR2_INIT_BUSYBOX</code> will
   ensure BusyBox will build and install its <code class="literal">init</code> program. This is
   the default solution in Buildroot. The BusyBox <code class="literal">init</code> program will
   read the <code class="literal">/etc/inittab</code> file at boot to know what to do. The syntax
   of this file can be found in
   <a class="ulink" href="http://git.busybox.net/busybox/tree/examples/inittab" target="_top">http://git.busybox.net/busybox/tree/examples/inittab</a> (note that
   BusyBox <code class="literal">inittab</code> syntax is special: do not use a random <code class="literal">inittab</code>
   documentation from the Internet to learn about BusyBox
   <code class="literal">inittab</code>). The default <code class="literal">inittab</code> in Buildroot is stored in
   <code class="literal">system/skeleton/etc/inittab</code>. Apart from mounting a few important
   filesystems, the main job the default inittab does is to start the
   <code class="literal">/etc/init.d/rcS</code> shell script, and start a <code class="literal">getty</code> program (which
   provides a login prompt).
</li><li class="listitem">
The second solution is <span class="strong"><strong>systemV</strong></span>. This solution uses the old
   traditional <span class="emphasis"><em>sysvinit</em></span> program, packed in Buildroot in
   <code class="literal">package/sysvinit</code>. This was the solution used in most desktop
   Linux distributions, until they switched to more recent
   alternatives such as Upstart or Systemd. <code class="literal">sysvinit</code> also works with
   an <code class="literal">inittab</code> file (which has a slightly different syntax than the
   one from BusyBox). The default <code class="literal">inittab</code> installed with this init
   solution is located in <code class="literal">package/sysvinit/inittab</code>.
</li><li class="listitem">
The third solution is <span class="strong"><strong>systemd</strong></span>. <code class="literal">systemd</code> is the new generation
   init system for Linux. It does far more than traditional <span class="emphasis"><em>init</em></span>
   programs: aggressive parallelization capabilities, uses socket and
   D-Bus activation for starting services, offers on-demand starting
   of daemons, keeps track of processes using Linux control groups,
   supports snapshotting and restoring of the system state,
   etc. <code class="literal">systemd</code> will be useful on relatively complex embedded
   systems, for example the ones requiring D-Bus and services
   communicating between each other. It is worth noting that <code class="literal">systemd</code>
   brings a fairly big number of large dependencies: <code class="literal">dbus</code>, <code class="literal">udev</code>
   and more. For more details about <code class="literal">systemd</code>, see
   <a class="ulink" href="http://www.freedesktop.org/wiki/Software/systemd" target="_top">http://www.freedesktop.org/wiki/Software/systemd</a>.
</li></ul></div><p>The solution recommended by Buildroot developers is to use the
<span class="strong"><strong>BusyBox init</strong></span> as it is sufficient for most embedded
systems. <span class="strong"><strong>systemd</strong></span> can be used for more complex situations.</p></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.idm370" class="footnote"><p><a href="#idm370" class="simpara"><sup class="simpara">[3] </sup></a>This terminology differs from what is used by GNU
configure, where the host is the machine on which the application will
run (which is usually the same as target)</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pt02.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="pt02.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch07.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>